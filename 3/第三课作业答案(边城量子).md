<center><h1 style="color:blue">ä»é›¶å¼€å§‹æ‰‹å†™VIO ç¬¬ä¸‰è¯¾ä½œä¸š</h1>
è¾¹åŸé‡å­ 2019.7.06</center>

## 1. æ ·ä¾‹ä»£ç ç»™å‡ºäº†ä½¿ç”¨LMç®—æ³•æ¥ä¼°è®¡æ›²çº¿$y=exp(ax^2 + bx + c)$å‚æ•°$a,b,c$çš„å®Œæ•´è¿‡ç¨‹
-  â‘  è¯·ç»˜åˆ¶æ ·ä¾‹ä»£ç ä¸­LMé˜»å°¼å› å­$\mu$éšç€è¿­ä»£å˜åŒ–çš„æ›²çº¿å›¾
-  â‘¡ å°†æ›²çº¿å‡½æ•°æ”¹æˆ $y=ax^2+bx+c$, è¯·ä¿®æ”¹æ ·ä¾‹ä»£ç ä¸­æ®‹å·®è®¡ç®—,é›…å¯æ¯”è®¡ç®—ç­‰å‡½æ•°, å®Œæˆæ›²çº¿å‚æ•°ä¼°è®¡.
-  ğŸŒ‚å¦‚æœæœ‰å®ç°å…¶ä»–é˜»å°¼å› å­æ›´æ–°ç­–ç•¥å¯åŠ åˆ†(é€‰åš).

### å›ç­”:
- #### ç›®æ ‡1:  ç»˜åˆ¶$\mu$çš„éšè¿­ä»£å˜åŒ–çš„æ›²çº¿å›¾
  - 1. å…ˆè¯´ç»“è®ºï¼Œç»è¿‡ä¿®æ”¹ä»£ç ï¼Œ åŠ å…¥æ‰“ç‚¹ä»£ç å¯¹Lambdaè¾“å‡ºï¼Œç¼–è¯‘æ‰§è¡Œï¼Œç„¶å ç¼–å†™pythonä»£ç ç”»å›¾è¾“å‡ºæ›²çº¿å›¾ï¼Œ æ›²çº¿å›¾å¦‚ä¸‹ï¼š
       - å·¦å›¾ä¸ºè¾“å‡ºäº†æ‰€æœ‰è¿­ä»£è¿‡ç¨‹ä¸­æ‰€æœ‰çš„ç‚¹ï¼ˆå³whileå¾ªç¯å†…éƒ¨çš„currentLambda_)çš„å˜åŒ–æƒ…å†µï¼Œ å³å›¾ä»…è¾“å‡ºæœ€ç»ˆæ¯æ¬¡è¿­ä»£çš„ç»“æœï¼ˆå³ä»…ä»…åœ¨whileå¾ªç¯ç»“æŸåè¾“å‡ºcurrentLambda_) ï¼›
       - å¯ä»¥çœ‹å‡ºä¸¤è€…åŒºåˆ«åœ¨äºï¼Œè¿­ä»£å†…éƒ¨è¿˜æ˜¯ç»å†äº†å…ˆå˜å¤§åå˜å°çš„è¿‡ç¨‹çš„ï¼›
    
    ![lambdaéšè¿­ä»£æ›²çº¿å˜åŒ–å›¾](D:\Study\vio\3\images\exp_lambda_output.jpg  "lambdaéšè¿­ä»£æ›²çº¿å˜åŒ–å›¾")
    
  - 2. ä¸‹é¢è®²è¿°æ•´ä¸ªä¿®æ”¹ä»£ç ï¼Œç¼–å†™Pythonçš„è¯¦ç»†è¿‡ç¨‹ï¼š
    
    - 1. ä¿®æ”¹`problem.cc`ä»£ç , å¯¹`currentLambda_`çš„å€¼è¿›è¡Œæ‰“ç‚¹å¹¶è¿½åŠ è¾“å‡ºåˆ°`points.txt`æ–‡ä»¶, ä¿®æ”¹åçš„`bool Problem::Solve()`å‡½æ•°å¦‚ä¸‹ï¼š
    
         å¤‡æ³¨ï¼šå¦‚ä¸‹ä»£ç ä»…å±•ç¤ºäº†æ‰“å°æ‰€æœ‰ç‚¹çš„æƒ…å†µï¼Œå³ä¸Šå›¾çš„å·¦å›¾ï¼Œ å¦‚æœä»…æ‰“å°æ¯æ¬¡è¿­ä»£ç»“æœï¼ŒæŠŠæ‰“ç‚¹ä»£ç ç§»åŠ¨åˆ°whileå¾ªç¯ä¹‹å¤–å³å¯:
    ```c++
    bool Problem::Solve(int iterations) {
        if (edges_.size() == 0 || verticies_.size() == 0) {
            std::cerr << "\nCannot solve problem without edges or verticies" << std::endl;
            return false;
        }
    
        TicToc t_solve;
        // ç»Ÿè®¡ä¼˜åŒ–å˜é‡çš„ç»´æ•°ï¼Œä¸ºæ„å»º H çŸ©é˜µåšå‡†å¤‡
        SetOrdering();
        // éå†edge, æ„å»º H = J^T * J çŸ©é˜µ
        MakeHessian();
        // LM åˆå§‹åŒ–
        ComputeLambdaInitLM();
        // LM ç®—æ³•è¿­ä»£æ±‚è§£  
    bool stop = false;  
        int iter = 0;
    
    	// -----  æ–°å¢ä»£ç  Start -------
        // åˆ é™¤æ—§çš„æ•°æ®æ–‡ä»¶
        std::string fpath = "points.txt";
        remove( fpath.c_str() );
        // -----  æ–°å¢ä»£ç  End -------
    
        while (!stop && (iter < iterations)) {
            std::cout << "iter: " << iter << " , chi= " << currentChi_ << " , Lambda= " << currentLambda_
                      << std::endl;
            
           
            bool oneStepSuccess = false;
            int false_cnt = 0;
            while (!oneStepSuccess)  // ä¸æ–­å°è¯• Lambda, ç›´åˆ°æˆåŠŸè¿­ä»£ä¸€æ­¥
            {
                // setLambda
                AddLambdatoHessianLM();
    
                // -----  æ–°å¢ä»£ç  Start -------
                // å¯¹æœ€æ–°çš„lambdaè¿›è¡Œè®°å½•, è®°å½•åˆ°points.txtæ–‡ä»¶ä¸­
                ofstream fin( fpath , ios::app);
                fin << currentLambda_ << endl;
                // -----  æ–°å¢ä»£ç  End -------
                
                // ç¬¬å››æ­¥ï¼Œè§£çº¿æ€§æ–¹ç¨‹ H X = B
                SolveLinearSystem();
                // 
                RemoveLambdaHessianLM();
    
                // ä¼˜åŒ–é€€å‡ºæ¡ä»¶1ï¼š delta_x_ å¾ˆå°åˆ™é€€å‡º
                if (delta_x_.squaredNorm() <= 1e-6 || false_cnt > 10) {
                    stop = true;
                    break;
            }
    
                // æ›´æ–°çŠ¶æ€é‡ X = X+ delta_x
                UpdateStates();
                // åˆ¤æ–­å½“å‰æ­¥æ˜¯å¦å¯è¡Œä»¥åŠ LM çš„ lambda æ€ä¹ˆæ›´æ–°
                oneStepSuccess = IsGoodStepInLM();
                // åç»­å¤„ç†ï¼Œ
                if (oneStepSuccess) {
                    // åœ¨æ–°çº¿æ€§åŒ–ç‚¹ æ„å»º hessian
                    MakeHessian();
                    false_cnt = 0;
                } else {
                    false_cnt++;
                    RollbackStates();   // è¯¯å·®æ²¡ä¸‹é™ï¼Œå›æ»š
                }
        }
        iter++;
    
            // ä¼˜åŒ–é€€å‡ºæ¡ä»¶3ï¼š currentChi_ è·Ÿç¬¬ä¸€æ¬¡çš„chi2ç›¸æ¯”ï¼Œä¸‹é™äº† 1e6 å€åˆ™é€€å‡º
        if (sqrt(currentChi_) <= stopThresholdLM_)
                stop = true;
        }
        std::cout << "problem solve cost: " << t_solve.toc() << " ms" << std::endl;
        std::cout << "   makeHessian cost: " << t_hessian_cost_ << " ms" << std::endl;
        return true;
    }
    ```
    
    - 2. ç¼–è¯‘è¿è¡ŒCurveFittingå·¥ç¨‹

      å»ºç«‹`build`ç›®å½•, è¿è¡Œå¯æ‰§è¡Œç¨‹åº, ç”Ÿæˆ`points.txt`ï¼Œä»ç¨‹åºè¾“å‡ºå¯çœ‹å‡ºï¼Œä¼˜åŒ–åçš„å‚æ•°å’ŒçœŸå®å€¼å·®åˆ«å¾ˆå°, åœ¨1e-2çº§åˆ«: 
    ```shell
        mkdir  build
        cd  build
        cmake ..
        make 
        cd  app
        ./testCurveFitting
      
       ç¨‹åºæ‰§è¡Œè¾“å‡ºå¦‚ä¸‹ï¼š
      
         Test CurveFitting start...
       iter: 0 , chi= 36048.3 , Lambda= 0.001
       iter: 1 , chi= 30015.5 , Lambda= 699.051
       iter: 2 , chi= 13421.2 , Lambda= 1864.14
       iter: 3 , chi= 7273.96 , Lambda= 1242.76
       iter: 4 , chi= 269.255 , Lambda= 414.252
       iter: 5 , chi= 105.473 , Lambda= 138.084
       iter: 6 , chi= 100.845 , Lambda= 46.028
       iter: 7 , chi= 95.9439 , Lambda= 15.3427
       iter: 8 , chi= 92.3017 , Lambda= 5.11423
       iter: 9 , chi= 91.442 , Lambda= 1.70474
       iter: 10 , chi= 91.3963 , Lambda= 0.568247
       iter: 11 , chi= 91.3959 , Lambda= 0.378832
       problem solve cost: 2.33059 ms
            makeHessian cost: 0.794637 ms
         -------After optimization, we got these parameters :
           0.941939  2.09453 0.965586
         -------ground truth:
         1.0,  2.0,  1.0
       
    ```
    
    - 3. ç¼–å†™ä¸€ä¸ªpythonè„šæœ¬`draw.py` ç”¨äºç»˜åˆ¶`points.txt`çš„ç‚¹çš„æŠ˜çº¿å›¾, å†…å®¹å¦‚ä¸‹æ‰€ç¤º:
        ```python
           # coding: utf-8
          
           # ç»˜å›¾åº“
           import matplotlib.pyplot as plt
           import numpy as np
          
           # lambdaç‚¹ä¿å­˜è·¯å¾„
           # æ ¼å¼: æ¯ä¸€è¡Œä¸€ä¸ªç‚¹
           filename = "/home/hadoop/Documents/CurveFitting_LM/build/app/points.txt"
          
           # ä¿å­˜ç‚¹çš„åˆ—è¡¨
           # points = []
          
           # æ–¹å¼1: è‡ªå·±è¯»å–æ¯ä¸€è¡Œ, å¾—åˆ°æ•°æ®
           # # è¯»å–points
           # with open(filename, 'r') as f:
           # 	lines = f.readlines()
           # 	for line in lines:
           # 		points.append(line)
          
           # æ–¹å¼2: ä½¿ç”¨np.loadtxtè¯»å–
           points = np.loadtxt(filename)
          
           # ç»˜å›¾
           plt.plot(points)
           plt.title('lambda')
           print("save to points.jpg")
           plt.savefig('points.jpg')
           plt.show()
        ```
    
    - 4. æ‰§è¡Œpythonè„šæœ¬, lambdaéšè¿­ä»£çš„å˜åŒ–å›¾å½¢å¦‚ä¸‹:
          ![lambdaéšè¿­ä»£æ›²çº¿å˜åŒ–å›¾](images\exp_lambda_1.jpg  "lambdaéšè¿­ä»£æ›²çº¿å˜åŒ–å›¾")
  
- #### ç›®æ ‡2:  å°†æ›²çº¿å‡½æ•°æ”¹æˆ $y=ax^2+bx+c$, è¯·ä¿®æ”¹æ ·ä¾‹ä»£ç ä¸­æ®‹å·®è®¡ç®—,é›…å¯æ¯”è®¡ç®—ç­‰å‡½æ•°, å®Œæˆæ›²çº¿å‚æ•°ä¼°è®¡
  - 1. ä¿®æ”¹`CurveFitting.cpp`ä»£ç çš„`ComputeReisdual()`å‡½æ•°:

    ```C++
        // è®¡ç®—æ›²çº¿æ¨¡å‹è¯¯å·®
        virtual void ComputeResidual() override
        {
            Vec3 abc = verticies_[0]->Parameters();  // ä¼°è®¡çš„å‚æ•°
             // æ„å»ºæ®‹å·®
            //residual_(0) = std::exp( abc(0)*x_*x_ + abc(1)*x_ + abc(2) ) - y_; 
            // æ®‹å·®å‡½æ•°ä¸º:  ( ax^2 + bx + c ) - y_
            residual_(0) = abc(0)*x_*x_  + abc(1)*x_ + abc(2) - y_;
        }
    ```
    
  - 2. ä¿®æ”¹`CurveFitting.cpp`ä»£ç çš„`ComputeJacobians()`å‡½æ•°:
  
    ```c++
        // è®¡ç®—æ®‹å·®å¯¹å˜é‡çš„é›…å…‹æ¯”
        virtual void ComputeJacobians() override
        {
            Vec3 abc = verticies_[0]->Parameters();
            double exp_y = std::exp( abc(0)*x_*x_ + abc(1)*x_ + abc(2) );

            Eigen::Matrix<double, 1, 3> jaco_abc;  // è¯¯å·®ä¸º1ç»´ï¼ŒçŠ¶æ€é‡ 3 ä¸ªï¼Œæ‰€ä»¥æ˜¯ 1x3 çš„é›…å…‹æ¯”çŸ©é˜µ
            //jaco_abc << x_ * x_ * exp_y, x_ * exp_y , 1 * exp_y;
            // ax^2 + bx + c åˆ†åˆ«å¯¹ a, b, cæ±‚åå¯¼
            jaco_abc << x_*x_,  x_,  1;
            jacobians_[0] = jaco_abc;
        }
    ```
  - 3. ä¿®æ”¹`CurveFitting.cpp`ä»£ç çš„`main()`å‡½æ•°å¦‚ä¸‹ï¼Œ <font color="red">æ³¨æ„æ•°æ®ç‚¹ä¸ªæ•°Nè¢«ä¿®æ”¹åˆ°äº†700ï¼Œ Lambdaçš„æ›²çº¿å›¾ä¼šå±•ç¤ºæ›´å¤šå˜åŒ–ç»†èŠ‚</font> :
    ```C++
        int main()
        {
            double a=1.0, b=2.0, c=1.0;         // çœŸå®å‚æ•°å€¼
            int N = 700;                        // æ•°æ®ç‚¹
            double w_sigma= 1.;                 // å™ªå£°Sigmaå€¼
  
            std::default_random_engine generator;
            std::normal_distribution<double> noise(0.,w_sigma);
  
            // æ„å»º problem
            Problem problem(Problem::ProblemType::GENERIC_PROBLEM);
            shared_ptr< CurveFittingVertex > vertex(new CurveFittingVertex());
  
            // è®¾å®šå¾…ä¼°è®¡å‚æ•° a, b, cåˆå§‹å€¼
            vertex->SetParameters(Eigen::Vector3d (0.,0.,0.));
            // å°†å¾…ä¼°è®¡çš„å‚æ•°åŠ å…¥æœ€å°äºŒä¹˜é—®é¢˜
            problem.AddVertex(vertex);
  
            // æ„é€  N æ¬¡è§‚æµ‹
            for (int i = 0; i < N; ++i) {
                double x = i/100.;
                double n = noise(generator);
                // -----  æ–°å¢ä»£ç  Start -------
                // è§‚æµ‹ y
                //double y = std::exp( a*x*x + b*x + c ) + n;
                double y = a*x*x  + b*x  + c  + n;
                // -----  æ–°å¢ä»£ç  End -------
  
                // æ¯ä¸ªè§‚æµ‹å¯¹åº”çš„æ®‹å·®å‡½æ•°
                shared_ptr< CurveFittingEdge > edge(new CurveFittingEdge(x,y));
                std::vector<std::shared_ptr<Vertex>> edge_vertex;
                edge_vertex.push_back(vertex);
                edge->SetVertex(edge_vertex);
  
                // æŠŠè¿™ä¸ªæ®‹å·®æ·»åŠ åˆ°æœ€å°äºŒä¹˜é—®é¢˜
                problem.AddEdge(edge);
          }
  
            std::cout<<"\nTest CurveFitting start..."<<std::endl;
            /// ä½¿ç”¨ LM æ±‚è§£
            problem.Solve(30);
  
            std::cout << "-------After optimization, we got these parameters :" << std::endl;
            std::cout << vertex->Parameters().transpose() << std::endl;
            std::cout << "-------ground truth: " << std::endl;
            std::cout << "1.0,  2.0,  1.0" << std::endl;
  
            // std
            return 0;
        }
    ```
  - 4. è¾“å‡ºå¦‚ä¸‹, å¯ä»¥çœ‹åˆ°ä¼˜åŒ–åçš„å‚æ•°å’ŒçœŸå®å€¼å·®åˆ«å¾ˆå°, åœ¨1.e-2çº§åˆ«:
    ```PowerShell
    Test CurveFitting start...
    iter: 0 , chi= 653482 , Lambda= 3.34941
    iter: 1 , chi= 696.818 , Lambda= 1.11647
    iter: 2 , chi= 696.767 , Lambda= 0.372156
    iter: 3 , chi= 696.767 , Lambda= 0.248104
    problem solve cost: 2.10817 ms
       makeHessian cost: 1.35818 ms
    -------After optimization, we got these parameters :
    1.00191 1.98871 0.98923
    -------ground truth:
    1.0,  2.0,  1.0
    ```
  - 5. æ‰§è¡Œpythonè„šæœ¬, lambdaéšè¿­ä»£çš„å˜åŒ–å›¾å½¢å¦‚ä¸‹:
![ax^2+bx+cçš„lambdaè¾“å‡ºå˜åŒ–](images\poly_lambda.jpg 'ax^2+bx+cçš„lambdaè¾“å‡ºå˜åŒ–')
  
  
  
- #### ç›®æ ‡3: å¦‚æœæœ‰å®ç°å…¶ä»–é˜»å°¼å› å­æ›´æ–°ç­–ç•¥å¯åŠ åˆ†(é€‰åš).
  
  - 1. ä¿®æ”¹`problom.cc`ä¸­`Problem::ComputeLambdaInitLM()`å‡½æ•°, ä½¿å¾—$\mu$å…·å¤‡ä¸¤ç§åˆå§‹åŒ–æ–¹å¼:
  
        1. ä¸€ç§æ˜¯ä½¿ç”¨HessionçŸ©é˜µå¯¹è§’çº¿æœ€å¤§å€¼ä½œä¸ºåˆå§‹å€¼, 
        
        2. ä¸€ç§åˆ™æ˜¯ç›´æ¥ä½¿ç”¨å›ºå®šå€¼ä¸ºåˆå§‹å€¼
        
        ä¿®æ”¹çš„å±€éƒ¨ä»£ç å¦‚ä¸‹:
        
        ```C++
        double tau = 1e-5;
        // åˆå€¼ç­–ç•¥1: ä½¿ç”¨HessiançŸ©é˜µå¯¹è§’çº¿ä¸Šçš„æœ€å¤§å€¼ä½œä¸ºåˆå§‹å€¼
        currentLambda_ = tau * maxDiagonal;
        
        // åˆå€¼ç­–ç•¥2: ä½¿ç”¨å›ºå®šå€¼ä½œä¸ºåˆå§‹å€¼
        //currentLambda_ = tau*0.1;
        ```
  
  - 2. ä¿®æ”¹`problom.cc`ä¸­`Problem::IsGoodStepInLM() `å‡½æ•°,  å®ç°å¦‚ä¸‹4ç§$\mu$çš„æ›´æ–°æ–¹å¼:
       * ç­–ç•¥1:  Nielsen é˜»å°¼å› å­æ›´æ–°ç­–ç•¥ , å³è¯¾ä»¶å…¬å¼13
    
        ```c++
        // rho > 0,  lambda = lambda * max(1/3, 1-(2*rho - 1)^3); nu = 2
        // rho <=0,  lambda = lambda * nu, nu = 2*nu;W
        ```
    
       * ç­–ç•¥2:  Marquardt é˜»å°¼å› å­æ›´æ–°ç­–ç•¥, è¯¾ä»¶å…¬å¼12
    
        ```c++
        // rho < 0.25 , lambda = lambda*2.0
        // rho > 0.75 , lambda = lambda/3.0
        ```
    
       * ç­–ç•¥3:  Quadratic é˜»å°¼å› å­æ›´æ–°ç­–ç•¥,  å‚è€ƒ "The Levenberg-Marquardt algorithm for nonlinear least squares curve-fitting problems, Henri P. Gavin"
    
        ```c++
        // h =  delta_x_*b 
        // diff = currentChi_ - tempChi;
        // alpha = h / (0.5*diff + h )
        // rho > 0, lambda = max( lambde/(1+alpha), 1.e-7)
        // rho <=0, lambda = lambda + abs(diff*0.5/alpha)
        ```
    
       * ç­–ç•¥4:  å¦å¤–ä¸€ç§å˜å½¢åçš„Levenberg  é˜»å°¼å› å­æ›´æ–°ç­–ç•¥ ,  å‚è€ƒ "http://www.duke.edu/~hpgavin/lm.m"
    
        ```C++
        // 9.0å’Œ11éƒ½æ˜¯ç»éªŒå€¼, æ§åˆ¶lambdaçš„å¢é•¿/å‡å°‘é€Ÿåº¦
        // rho > 0, lambda = max( lambda/9.0, 1.e-7 )
        // rho <=0, lambda = min( lambda*11,  1e7 )
        ```
    
  - 3. å››ç§ç­–ç•¥æ‰§è¡Œç»“æœä¸Lambdaéšè¿­ä»£å˜åŒ–æ›²çº¿å›¾æ¯”è¾ƒå¦‚ä¸‹:   
  
      <b>é’ˆå¯¹  $ax^2 + bx + c$ è¿›è¡Œæ‹Ÿåˆ</b>
      ç¨‹åºä¸­å…¶ä»–å‚æ•°ï¼šã€€  
    int N = 700;   ä¸” lambda ä½¿ç”¨HessiançŸ©é˜µå¯¹è§’çº¿ä¸Šçš„æœ€å¤§å€¼ä½œä¸ºåˆå§‹å€¼
  

![å››ç§lambdaç­–ç•¥æ¯”è¾ƒ](D:\Study\vio\3\images\all.png "å››ç§ç­–ç•¥æ¯”è¾ƒå›¾ç‰‡")

  - 4. å››ç§æ›´æ–°æ–¹å¼çš„ä»£ç å¦‚ä¸‹æ‰€ç¤º:
  
    ```c++
    bool Problem::IsGoodStepInLM() {
        double scale = 0;
        // å¯¹åº”è¯¾ä»¶å…¬å¼11, å¾—åˆ° scale = L(0) - L(delta_x)
        //  currentLambda_ å³è¯¾ä»¶ä¸­çš„ Î¼
        scale = delta_x_.transpose() * (currentLambda_ * delta_x_ + b_);
        scale += 1e-3;    // make sure it's non-zero :)
    
        // recompute residuals after update state
        // ç»Ÿè®¡æ‰€æœ‰çš„æ®‹å·®, å³å…¬å¼10çš„åˆ†å­éƒ¨åˆ†çš„  F(x+delta_x)
        double tempChi = 0.0;
        for (auto edge: edges_) {
            edge.second->ComputeResidual();
            tempChi += edge.second->Chi2();
      }
    
        // è®¡ç®—æ¯”ä¾‹å› å­, å…¬å¼10 çš„rho
        double rho = (currentChi_ - tempChi) / scale;
        // é˜»å°¼å› å­æ›´æ–°ç­–ç•¥é€‰æ‹©å™¨ strategy ,æœ‰å¤šç§ç­–ç•¥å¯é€‰æ‹©
        int strategy = 4;
        switch ( strategy ) {
            case 1:  // Nielsen é˜»å°¼å› å­æ›´æ–°ç­–ç•¥ , å³è¯¾ä»¶å…¬å¼13
                // rho > 0,  lambda = lambda * max(1/3, 1-(2*rho - 1)^3); nu = 2
                // rho <=0,  lambda = lambda * nu, nu = 2*nu;W
                if (rho > 0 && isfinite(tempChi))   // last step was good, è¯¯å·®åœ¨ä¸‹é™
                {
                    double alpha = 1. - pow((2 * rho - 1), 3);
                    alpha = std::min(alpha, 2. / 3.);
                    double scaleFactor = (std::max)(1. / 3., alpha);
                    currentLambda_ *= scaleFactor;
                    ni_ = 2;
                    currentChi_ = tempChi;
                    return true;
                } else {
                    currentLambda_ *= ni_;
                    ni_ *= 2;
                    return false;
                }
                break;
            case 2: // Marquardtçš„é˜»å°¼ç­–ç•¥, è¯¾ä»¶å…¬å¼12
                // rho < 0.25 , lambda = lambda*2.0
                // rho > 0.75 , lambda = lambda/3.0
                // å¤‡æ³¨: åœ¨æœ¬ä¾‹ä¸­, æ­¤æ–¹æ³•æ— æ³•ä¼˜åŒ–å¾—åˆ°åˆé€‚çš„a,b,cçš„å€¼
                if ( rho < 0.25 && isfinite(tempChi)) {
                    currentLambda_ *= 2.0;
                    currentChi_ = tempChi;
                    return true;
                }else if ( rho > 0.75 && isfinite(tempChi) ) {
                    currentLambda_ /= 3.0;
                    currentChi_ = tempChi;
                    return true;    
                } else {
                    // do nothing
                    return false;
                }
                break;
            case 3:  // Quadraticç­–ç•¥
                //å‚è§è®ºæ–‡"The Levenberg-Marquardt algorithm for nonlinear least squares curve-fitting problems, Henri P. Gavin"
                // h =  delta_x_*b 
                // diff = currentChi_ - tempChi;
                // alpha = h / (0.5*diff + h )
                // rho > 0, lambda = max( lambde/(1+alpha), 1.e-7)
                // rho <=0, lambda = lambda + abs(diff*0.5/alpha)
                { // ä»£ç å—, é¿å…ç¼–è¯‘å‡ºç°é”™è¯¯æç¤º(æœ¬caseå—åˆå§‹åŒ–å˜é‡è¿›å…¥ä¸‹ä¸€ä¸ªcase)
                    double  h = delta_x_.transpose() * b_;
                    double  diff = currentChi_ - tempChi;
                    double  alpha_ = h / (0.5*diff + h);
                    if ( rho > 0 && isfinite(tempChi) ){
                        currentLambda_ = std::max(currentLambda_/(1+alpha_), 1.e-7 );
                        currentChi_ = tempChi;
                        return true;
                    }else if( rho <=0 && isfinite(tempChi) ){
                        currentLambda_ = currentLambda_ + std::abs(diff*0.5/alpha_);
                        currentChi_ = tempChi;
                        return true;
                    } else {
                        // do nothing
                        return false;
                    }
                }
                break;
            case 4: //Levenberg ç­–ç•¥ 
              // å‚è€ƒ"http://www.duke.edu/~hpgavin/lm.m"
              // 9.0å’Œ11éƒ½æ˜¯ç»éªŒå€¼, æ§åˆ¶lambdaçš„å¢é•¿/å‡å°‘é€Ÿåº¦
                // rho > 0, lambda = lambda/9.0
                // rho <=0, lambda = lambda*11
                if ( rho > 0 && isfinite(tempChi)) {
                    currentLambda_ = std::max(currentLambda_/9.0, 1.e-7);
                    currentChi_ = tempChi;
                    return true;
                }else if( rho <=0 && isfinite(tempChi)) {
                    currentLambda_ = std::min(currentLambda_*11, 1.e7);
                    currentChi_ = tempChi;
                    return true;
                }else{
                    // do nothing
                    return false;
                }
                break;
        }
    }
    ```



## ï¼’. å…¬å¼æ¨å¯¼,æ ¹æ®è¯¾ç¨‹çŸ¥è¯†,å®Œæˆ$\mathbf{F}$,$\mathbf{G}$ä¸­å¦‚ä¸‹ä¸¤é¡¹çš„æ¨å¯¼è¿‡ç¨‹ï¼š
$$
\begin{aligned}
\mathbf{f}_{15} &=\frac{\partial \boldsymbol{\alpha}_{b_{i} b_{k+1}}}{\partial \delta \mathbf{b}_{k}^{g}}=-\frac{1}{4}\left(\mathbf{R}_{b_{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k}}-\mathbf{b}_{k}^{a}\right)\right]_\times  \delta t^{2}\right)(-\delta t)   
\\
\mathbf{g}_{12} &=\frac{\partial \boldsymbol{\alpha}_{b_{i} b_{k+1}}}{\partial \mathbf{n}_{k}^{g}}=-\frac{1}{4}\left(\mathbf{R}_{b_{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k}}-\mathbf{b}_{k}^{a}\right)\right]_\times \delta t^{2}\right)\left(\frac{1}{2} \delta t\right)   
\end{aligned}
$$

### å›ç­”1:  $f_{15}$æ¨å¯¼:

å…¶ä¸­åˆ†å­ $ \boldsymbol{\alpha}_{b_{i}b_{k+1}} = \boldsymbol{ \alpha}_{b_{i}b_{k}} + \boldsymbol{ \beta }_{b_{i}b_{k}} \delta t + \frac{1}{2} a \delta t^2  $ ,

ç”±äºæ˜¯å¯¹kæ—¶åˆ»çš„$\delta b_k^g$æ±‚å¯¼, å› æ­¤å‰ä¸¤é¡¹å‡ä¸å®ƒæ— å…³, æ‰€ä»¥å¯ç•¥å».  

ç¬¬ä¸‰é¡¹ä¸­çš„aå¯è¡¨ç¤ºä¸º: $a=\frac{1}{2}(q_{b_{i}b_{k}}(a^{b_k} + n_k^a - b_k^a) + q_{b_{i}b_{k+1}}(a^{b_{k+1}} + n_{k+1}^a - b_{k}^a) )$ , å…¶ä¸­å‰åŠéƒ¨åˆ†åœ¨å¯¹$\delta  \mathbf{b}_k^g$æ±‚å¯¼æ—¶æ— å…³, å¯ç•¥å»; åä¸€é¡¹ä¸­çš„$n_{k+1}^g$å·²ç»è¢«åŒ…å«åœ¨$a^{b_{k+1}}$ä¸­, å› æ­¤ä¹Ÿç•¥å»; 

å› æ­¤$f_{15}$å¯å˜ä¸ºå¦‚ä¸‹å½¢å¼,  ç„¶ååŠ å…¥å³æ‰°åŠ¨$ \left [ \begin{array} {c}{1} \\-{\frac{1}{2} \mathbf{ \delta b}_k^g \delta t} \end{array} \right ]$ å¹¶è½¬åŒ–ä¸ºæ—‹è½¬çŸ©é˜µå½¢å¼, å±•å¼€$\exp$ , å¹¶åˆ©ç”¨å‰ä¹˜æ€§è´¨äº¤æ¢é¡ºåº, æœ€åå¾—åˆ°ç»“æœ:
$$
\begin{equation}  
\begin{aligned}
\boldsymbol{f}_{15} &= \frac { \partial \boldsymbol{\alpha}_{b_{i}b_{k+1}} }{ \partial \delta \boldsymbol{b}_k^g} \\
&= \frac {1}{4} \frac { \partial \mathbf{q}_{b_{i}b_{k+1}} \otimes \left[ \begin{array} {c} 1 \\ - \frac{1}{2} \delta \boldsymbol{b}_k^g \delta t  \end{array} \right] \left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^{a} \right) \delta t^2 }  { \partial \delta \boldsymbol{b}_k^g } \\
&= \frac {1}{4} \frac { \partial \mathbf{R}_{b_{i}b_{k+1}} \exp \left( \left[ - \delta \mathbf{b}_k^g \delta t \right]_{\times} \right)  \left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^{a} \right) \delta t^2  }  { \partial \delta \boldsymbol{b}_k^g } \\
&\approx \frac {1}{4} \frac { \partial \mathbf{R}_{b{i}b_{k+1}} \left( \mathbf{I} + [- \delta \mathbf{b}_k^g \delta t ]_{\times} \right) \left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^{a} \right) \delta t^2 } { \partial \delta \boldsymbol{b}_k^g } \\
&= \frac {1}{4} \frac {- \partial \mathbf{R}_{b_{i}b_{k+1}} \left[ \left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^{a} \right)  \right]_{\times} \delta t^2 \left( - \delta \mathbf{b}_k^g \delta t \right) } { \partial \delta \boldsymbol{b}_k^g } \\
&= - \frac {1}{4} ( \mathbf{R}_{b_{i}b_{k+1}} \left[ \left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^{a} \right)  \right]_{\times} \delta t^2 ) (- \delta t)
\end{aligned}
\end{equation}
$$


### å›ç­”2:  $g_{12}$æ¨å¯¼:

å…¶ä¸­åˆ†å­ $ \boldsymbol{\alpha}_{b_{i}b_{k+1}} = \boldsymbol{ \alpha}_{b_{i}b_{k}} + \boldsymbol{ \beta }_{b_{i}b_{k}} \delta t + \frac{1}{2} a \delta t^2  $ ,

ç”±äºæ˜¯å¯¹kæ—¶åˆ»çš„$\boldsymbol{n}_k^g$æ±‚å¯¼, å› æ­¤å‰ä¸¤é¡¹å‡ä¸å®ƒæ— å…³(å’Œk-1æ—¶åˆ»çš„$\boldsymbol{n}_{k-1}^g$æœ‰å…³), å› æ­¤å¯ç•¥å».  

ç¬¬ä¸‰é¡¹ä¸­çš„aå¯è¡¨ç¤ºä¸º $a=\frac{1}{2}(q_{b_{i}b_{k}}(a^{b_k} + n_k^a - b_k^a) + q_{b_{i}b_{k+1}}(a^{b_{k+1}} + n_{k+1}^a - b_{k}^a) )$ , å…¶ä¸­å‰åŠéƒ¨åˆ†åœ¨å¯¹$\boldsymbol{n}_k^g$æ±‚å¯¼æ—¶æ— å…³, å¯ç•¥å»; åä¸€é¡¹ä¸­çš„$n_{k+1}^g$å·²ç»è¢«åŒ…å«åœ¨$a^{b_{k+1}}$ä¸­, å› æ­¤ä¹Ÿç•¥å»; 

å› æ­¤$g_{12}$å¯å˜ä¸ºå¦‚ä¸‹å½¢å¼,  ç„¶ååŠ å…¥å³æ‰°åŠ¨$[ \begin{array} {c}{1} \\{\frac{1}{4} \mathbf{n}_k^g \delta t} \end{array}]$ å¹¶è½¬åŒ–ä¸ºæ—‹è½¬çŸ©é˜µå½¢å¼, å±•å¼€$\exp$ , å¹¶åˆ©ç”¨å‰ä¹˜æ€§è´¨äº¤æ¢é¡ºåº, æœ€åå¾—åˆ°ç»“æœ:
$$
\begin{equation}  
\begin{split}
\boldsymbol{g}_{12} &= \frac {\partial \boldsymbol{\alpha}_{b_{i}b_{k+1}} } { \partial \mathbf{n}_{k}^{g} }   \\
&= \frac {1}{4} \frac { \partial \mathbf{q}_{b_{i}b_{k+1}} \otimes  \left[ \begin{array} {c}{1}\\ \frac{1}{4} \boldsymbol{n}_k^g \delta t \end{array}\right] ( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^a ) \delta t^2 } { \partial \mathbf{n}_k^g } \\
&= \frac {1}{4} \frac { \partial \mathbf{R}_{b_{i}b_{k+1}} \exp \left ( \left[ \frac{1}{2} \boldsymbol{n}_k^g \delta t \right]_\times \right ) \left( \mathbf{a}^{b_{k+1}} - b_k^a \right ) \delta t^2  }{ \partial \mathbf{n}_k^g } \\
&\approx \frac {1}{4} \frac { \partial \mathbf{R}_{b_{i}b_{k+1}} \left( \mathbf{I} + [ \frac{1}{2} \mathbf{n}_k^g \delta t]_{\times} \right) \left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^a \right ) \delta t^2  }{ \partial \mathbf{n}_k^g } \\
&=  \frac {1}{4} \frac { \partial \mathbf{R}_{b_{i}b_{k+1}} [ \frac{1}{2} \mathbf{n}_k^g \delta t]_{\times} \left( \mathbf{a}^{b_{k+1}} - b_k^a \right ) \delta t^2  }{ \partial \mathbf{n}_k^g }  \\
&=  - \frac {1}{4} \frac { \partial \mathbf{R}_{b_{i}b_{k+1}} \left[\left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^a \right ) \right]_{\times} \delta t^2  (\frac{1}{2} \mathbf{n}_k^g \delta t) }{ \partial \mathbf{n}_k^g } \\
&=  - \frac {1}{4} \left( \mathbf{R}_{b_{i}b_{k+1}} [\left( \mathbf{a}^{b_{k+1}} - \mathbf{b}_k^a \right )]_{\times} \delta t^2 \right)  (\frac{1}{2} \delta t) 
\end{split}
\end{equation}
$$


## 3. è¯æ˜å¼(9).
### é¢˜ç›®:
å·²çŸ¥é˜»å°¼å› å­å®šä¹‰:
$$
\begin{equation}  
\begin{aligned}
( \mathbf{J}^{\top} \mathbf{J} + \mu \mathbf{I} ) \Delta \mathbf{x}_{lm} = - \mathbf{J}^{\top} \mathbf{f} \qquad  with \quad \mu \ge 0
\end{aligned}
\end{equation}  
$$
é˜»å°¼å› å­ $ \mu $ å¤§å°æ˜¯ç›¸å¯¹ä¸ $ \mathbf{J}^{\top} \mathbf{J} $ çš„å…ƒç´ è€Œè¨€çš„ã€‚ åŠæ­£å®šçš„ä¿¡æ¯çŸ©é˜µ $ \mathbf{J}^{\top} \mathbf{J} $ ç‰¹å¾å€¼ ${ \lambda_j }$ å’Œå¯¹åº”çš„ç‰¹å¾å‘é‡ä¸º $\mathbf{v}_j$ ã€‚å¯¹  $ \mathbf{J}^{\top} \mathbf{J} $ åšç‰¹å¾å€¼åˆ†è§£åæœ‰ï¼š  $ \mathbf{J}^{\top} \mathbf{J} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^{\top} $ , å¯å¾—ï¼š
$$
\Delta \mathbf{x}_{1 \mathrm{m}}=-\sum_{j=1}^{n} \frac{\mathbf{v}_{j}^{\top} \mathbf{F}^{\prime \top}}{\lambda_{j}+\mu} \mathbf{v}_{j}
$$

### å›ç­”:

ç”± $ \mathbf{J}^{\top} \mathbf{J} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^{\top} $ , å¯çŸ¥å…¶ä¸ºå¯¹ç§°çŸ©é˜µ,  å®ƒæœ‰nä¸ªçº¿æ€§æ— å…³çš„ç‰¹å¾å‘é‡,  è®¾ $\lambda_i$ ä¸ºç‰¹å¾å€¼,  $ \mathbf{V}=(v_1, v_2, \cdots , v_n) $ , å…¶ä¸­ $v_i$ æ˜¯åˆ—å‘é‡,  æ˜¯nä¸ªç‰¹å¾å‘é‡é€šè¿‡æ­£äº¤å•ä½åŒ–å¾—åˆ°çš„ä¸€ç»„æ­£äº¤ä¸”æ¨¡ä¸º1çš„å‘é‡ ï¼Œå¯çŸ¥ $V$ ä¸ºæ­£äº¤çŸ©é˜µï¼Œ$\Lambda$ ä¸ºå¯¹è§’çŸ©é˜µã€‚

å› æ­¤è¿™ä¸ªå¯¹ç§°çŸ©é˜µæœ‰å¦‚ä¸‹æ€§è´¨ ï¼ˆåˆ©ç”¨äº† æ­£äº¤çŸ©é˜µ $ \mathbf{V} \mathbf{V}^{\top} = \mathbf{I}$ , ä»è€Œ $\mathbf{V}^{-1} = \mathbf{V}^{\top}$çš„æ€§è´¨ ï¼‰:

$(\mathbf{J}^\top \mathbf{J}) ^{-1}= (\mathbf{V} \Lambda \mathbf{V}^{\top})^{-1} = (\mathbf{V}^{\top})^{-1} \Lambda^{-1} \mathbf{V}^{-1}= \mathbf{V} \Lambda^{-1} \mathbf{V}^{\top}$,   å…¶ä¸­ $[\Lambda^{-1}]_{ii} = \frac {1}{\lambda_i}$

ä»£å…¥å…¬å¼(4):
$$
\begin{aligned}
\Delta \mathbf{x}_{lm} &= (\mathbf{J}^{\top} \mathbf{J} + \mu \mathbf{I})^{-1}  (- \mathbf{J}^{\top} \mathbf{f} ) \\
&= ( \mathbf{V} diag(\lambda_1 + \mu \quad \lambda_2 + \mu \quad \cdots \quad  \lambda_n + \mu ) \mathbf{V}^{\top} )^{-1}  (- \mathbf{J}^{\top} \mathbf{f} ) \\
&= \mathbf{V} diag \left( \frac {1}{\lambda_1 + \mu} \quad \frac {1}{\lambda_2 + \mu} \quad \cdots \quad  \frac {1}{\lambda_n + \mu} \right) \mathbf{V}^{\top}  \left(- \mathbf{J}^{\top} \mathbf{f} \right) \\
&= \left[ v_1  \quad  v_2 \quad \cdots \quad v_n  \right ] \left[ 
 \begin{matrix} 
        \frac{1}{ \lambda_1 + \mu} & 0    & \cdots & 0 \\ 
        0  & \frac {1}{\lambda_2 + \mu }  & \cdots & 0 \\
        \vdots                     & \vdots &\ddots & \vdots   \\
        0 & \cdots & \cdots & \frac {1}{\lambda_n + \mu} 
 \end{matrix} \right]
 \left[ \begin{array} {c} v_1^{\top} \\ v_2^{\top} \\ \vdots \\ v_n^{\top} \end{array} \right ]
  \left(- \mathbf{J}^{\top} \mathbf{f} \right) \\
&= - \sum_{j=1}^{n} \frac { v_j^{\top} \mathbf{F^{\prime \top} } } {\lambda_j + \mu}  v_j  
\end{aligned}
$$

æœ€åä¸€æ­¥æ¨å¯¼è¿‡ç¨‹è¯´æ˜ï¼š

ä½¿ç”¨çŸ©é˜µä¹˜æ³•çš„ç»“åˆå¾‹ï¼Œä»å³å‘å·¦è®¡ç®—:

*  $ \mathbf{F^{\prime \top}} = \mathbf{J^{\top} \mathbf{f} }$ æ˜¯ä¸€ä¸ªåˆ—å‘é‡ï¼Œ è€Œ $v_j^{\top}$ æ˜¯ä¸€ä¸ªè¡Œå‘é‡ï¼Œ æ‰€ä»¥ç›¸ä¹˜ä¹‹åçš„é‡  $v_j^{\top} \mathbf{F}^{\prime \top} $ æ˜¯ä¸€ä¸ªæ ‡é‡ï¼Œnä¸ªæ ‡é‡  $v_j^{\top} \mathbf{F}^{\prime \top} $ ç»„æˆçš„æ˜¯ä¸€ä¸ªæ–°çš„åˆ—å‘é‡ $ [ v_1^{\top} \mathbf{F}^{\prime \top}  \quad v_2^{\top} \mathbf{F}^{\prime \top} \cdots  v_n^{\top} \mathbf{F}^{\prime \top}   ] $ï¼›

* è¿™ä¸ªåˆ—å‘é‡å†å’Œå‰é¢çš„å¯¹è§’é˜µç›¸ä¹˜åï¼Œ ç»“æœä¾ç„¶è¿˜æ˜¯ä¸€ä¸ªåˆ—å‘é‡ï¼Œåˆ—å‘é‡çš„æ¯ä¸€é¡¹å€¼æ˜¯ $ \frac { v_j^{\top} \mathbf{F}^{\prime \top} } { \lambda_j + \mu }$ ;

* è¿™ä¸ªåˆ—å‘é‡å†å’Œå‰é¢çš„çŸ©é˜µ $ [ v_1 \quad v_2 \quad \cdots v_n] $  ç›¸ä¹˜ï¼Œ ä¹˜å‡ºæ¥æ¯ä¸€é¡¹éƒ½æ˜¯ $ \frac { v_j^{\top} \mathbf{F}^{\prime \top} } { \lambda_j + \mu } v_j$ , å†™æˆæ±‚å’Œå½¢å¼å³ä¸ºï¼š

  $ \sum_{j=1}^{n} \frac { v_j^{\top} \mathbf{F^{\prime \top} } } {\lambda_j + \mu}  v_j  $

* å†æ·»ä¸Šè´Ÿå·å³ä¸ºå…¬å¼(9)