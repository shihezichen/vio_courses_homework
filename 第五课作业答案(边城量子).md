<center><h1 style="color:blue">ä»é›¶å¼€å§‹æ‰‹å†™VIO ç¬¬äº”è¯¾ä½œä¸š</h1>
è¾¹åŸé‡å­ 2019.07.20</center>

## åŸºç¡€é¢˜
### 1. å®Œæˆå•ç›® $Bundle Adjustment$ æ±‚è§£å™¨ $ problem.cc $ ä¸­çš„éƒ¨åˆ†ä»£ç .
-  â‘  å®Œæˆ $Problem::MakeHessian() $ ä¸­ä¿¡æ¯çŸ©é˜µ $H$ çš„è®¡ç®—
-  â‘¡ å®Œæˆ $Problem::SolveLinearSystem() $ ä¸­ $SLAM$ é—®é¢˜çš„æ±‚è§£
### 2. å®Œæˆæ»‘åŠ¨çª—å£ç®—æ³•æµ‹è¯•å‡½æ•°
- ğŸŒ‚ å®Œæˆ $Problem::TestMarginalize()$ ä¸­çš„ä»£ç , å¹¶é€šè¿‡æµ‹è¯•.

  

### ä»¥ä¸Šä¸¤ä¸ªé—®é¢˜çš„å›ç­”:
- 1. ä¿®æ”¹ `problem.cc` ä¸­çš„ `Problem::MakeHessian()` å‡½æ•°:
     
     -  æ–°å¢ä»£ç ç‰‡æ®µå¦‚ä¸‹:
     
       ```c++
       // TODO:: home work. å®Œæˆ H index çš„å¡«å†™.
       H.block(index_i, index_j, dim_i, dim_j).noalias() += hessian;   // æ”¾åˆ°çŸ©é˜µçš„å“ªä¸€ç»´åº¦, ç»´åº¦æ˜¯å¤šå°‘, ç±»ä¼¼ä¸‹é¢çš„b.segment
       if (j != i) {
           // å¯¹ç§°çš„ä¸‹ä¸‰è§’
           // TODO:: home work. å®Œæˆ H index çš„å¡«å†™.
           H.block(index_j, index_i, dim_j, dim_i).noalias() += hessian.transpose();
       }
       ```
     
     -  å®Œæ•´çš„ `Problem::MakeHessian()` å‡½æ•°å¦‚ä¸‹:
     
       ```c++
       void Problem::MakeHessian() {
           TicToc t_h;
           // ç›´æ¥æ„é€ å¤§çš„ H çŸ©é˜µ
           ulong size = ordering_generic_;
           MatXX H(MatXX::Zero(size, size));
           VecX b(VecX::Zero(size));
       
           for (auto &edge: edges_) {
       
               // éå†æ‰€æœ‰è¾¹
               edge.second->ComputeResidual();
               edge.second->ComputeJacobians();
       
               auto jacobians = edge.second->Jacobians();
               auto verticies = edge.second->Verticies();
               assert(jacobians.size() == verticies.size());
               for (size_t i = 0; i < verticies.size(); ++i) {
                   auto v_i = verticies[i];
                   if (v_i->IsFixed()) continue;    // Hessian é‡Œä¸éœ€è¦æ·»åŠ å®ƒçš„ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯å®ƒçš„é›…å…‹æ¯”ä¸º 0
       
                   auto jacobian_i = jacobians[i];
                   ulong index_i = v_i->OrderingId();
                   ulong dim_i = v_i->LocalDimension();   // è¿™ä¸ªé¡¶ç‚¹æ˜¯å‡ ç»´çš„
       
                   MatXX JtW = jacobian_i.transpose() * edge.second->Information();
                   for (size_t j = i; j < verticies.size(); ++j) {
                       auto v_j = verticies[j];
       
                       if (v_j->IsFixed()) continue;
       
                       auto jacobian_j = jacobians[j];
                       ulong index_j = v_j->OrderingId();
                       ulong dim_j = v_j->LocalDimension();
       
                       assert(v_j->OrderingId() != -1);
                       MatXX hessian = JtW * jacobian_j;
                       // æ‰€æœ‰çš„ä¿¡æ¯çŸ©é˜µå åŠ èµ·æ¥
                       
                       // TODO:: home work. å®Œæˆ H index çš„å¡«å†™.
                       H.block(index_i, index_j, dim_i, dim_j).noalias() += hessian;   // æ”¾åˆ°çŸ©é˜µçš„å“ªä¸€ç»´åº¦, ç»´åº¦æ˜¯å¤šå°‘, ç±»ä¼¼ä¸‹é¢çš„b.segment
                       if (j != i) {
                          // å¯¹ç§°çš„ä¸‹ä¸‰è§’
       		    	   // TODO:: home work. å®Œæˆ H index çš„å¡«å†™.
                          H.block(index_j, index_i, dim_j, dim_i).noalias() += hessian.transpose();
                       }
                   }
                   b.segment(index_i, dim_i).noalias() -= JtW * edge.second->Residual();
               }
       
           }
       
           Hessian_ = H;
           b_ = b;
           t_hessian_cost_ += t_h.toc();
       
       
       //    Eigen::JacobiSVD<Eigen::MatrixXd> svd(H, Eigen::ComputeThinU | Eigen::ComputeThinV);
       //    std::cout << svd.singularValues() <<std::endl;
       
           if (err_prior_.rows() > 0) {
               b_prior_ -= H_prior_ * delta_x_.head(ordering_poses_);   // update the error_prior
           }
           Hessian_.topLeftCorner(ordering_poses_, ordering_poses_) += H_prior_;
           b_.head(ordering_poses_) += b_prior_;
       
           delta_x_ = VecX::Zero(size);  // initial delta_x = 0_n;
       
       }
       ```
  
- 2. ä¿®æ”¹ `problem.cc` ä¸­çš„ `Problem::SolveLinearSystem()` å‡½æ•°ï¼š
  
     -  ä¿®æ”¹çš„åçš„ `SolveLinearSystem()`ä»£ç å¦‚ä¸‹:
  
       ```c++
       
       /*
        * Solve Hx = b, we can use PCG iterative method or use sparse Cholesky
        */
       void Problem::SolveLinearSystem() {
       
           if (problemType_ == ProblemType::GENERIC_PROBLEM) {
       
               // é SLAM é—®é¢˜ç›´æ¥æ±‚è§£
               // PCG solver
               MatXX H = Hessian_;
               for (ulong i = 0; i < Hessian_.cols(); ++i) {
                   H(i, i) += currentLambda_;
               }
       //        delta_x_ = PCGSolver(H, b_, H.rows() * 2);
               delta_x_ = Hessian_.inverse() * b_;
       
           } 
           else {
       
               // SLAM é—®é¢˜é‡‡ç”¨èˆ’å°”è¡¥çš„è®¡ç®—æ–¹å¼
               // step1: schur marginalization --> Hpp, bpp
               int reserve_size = ordering_poses_;
               int marg_size = ordering_landmarks_;
       
               // TODO:: home work. å®ŒæˆçŸ©é˜µå—å–å€¼ï¼ŒHmmï¼ŒHpmï¼ŒHmpï¼Œbppï¼Œbmm (å–å‡ºå¯¹åº”ç»´åº¦)
               MatXX Hmm = Hessian_.block(reserve_size, reserve_size, marg_size, marg_size);
               MatXX Hpm = Hessian_.block(0, reserve_size, reserve_size, marg_size);
               MatXX Hmp = Hessian_.block(reserve_size, 0, marg_size, reserve_size);
               VecX bpp = b_.segment(0, reserve_size);
               VecX bmm = b_.segment(reserve_size, marg_size);
       
               // Hmm æ˜¯å¯¹è§’çº¿çŸ©é˜µï¼Œå®ƒçš„æ±‚é€†å¯ä»¥ç›´æ¥ä¸ºå¯¹è§’çº¿å—åˆ†åˆ«æ±‚é€†ï¼Œå¦‚æœæ˜¯é€†æ·±åº¦ï¼Œå¯¹è§’çº¿å—ä¸º1ç»´çš„ï¼Œåˆ™ç›´æ¥ä¸ºå¯¹è§’çº¿çš„å€’æ•°ï¼Œè¿™é‡Œå¯ä»¥åŠ é€Ÿ
               MatXX Hmm_inv(MatXX::Zero(marg_size, marg_size));
               for (auto landmarkVertex : idx_landmark_vertices_) {
                   int idx = landmarkVertex.second->OrderingId() - reserve_size;
                   int size = landmarkVertex.second->LocalDimension();
                   Hmm_inv.block(idx, idx, size, size) = Hmm.block(idx, idx, size, size).inverse();
               }
       
               // TODO:: home work. å®Œæˆèˆ’å°”è¡¥ Hpp, bpp ä»£ç 
               // è®¡ç®—b_pp_schurå’ŒH_pp_schu æ—¶éƒ½éœ€è¦ç”¨åˆ°çš„ä¸­é—´å˜é‡ Hpm * Hmm_inv
               MatXX Hpm_Hmm = Hpm * Hmm_inv;
               //  è®¡ç®— Hpm * Hmm_inv * Hmp 
               H_pp_schur_ = Hessian_.block(0,0,reserve_size, reserve_size) - Hpm_Hmm * Hmp;
               //  è®¡ç®— Hpm * Hmm_inv * bmm
               b_pp_schur_ = bpp - Hpm_Hmm * bmm;
       
               // step2: solve Hpp * delta_x = bpp
               VecX delta_x_pp(VecX::Zero(reserve_size));
               // PCG Solver
               for (ulong i = 0; i < ordering_poses_; ++i) {
                   H_pp_schur_(i, i) += currentLambda_;
               }
       
               int n = H_pp_schur_.rows() * 2;                       // è¿­ä»£æ¬¡æ•°
               delta_x_pp = PCGSolver(H_pp_schur_, b_pp_schur_, n);  // å“ˆå“ˆï¼Œå°è§„æ¨¡é—®é¢˜ï¼Œæ pcg èŠ±é‡Œèƒ¡å“¨
               delta_x_.head(reserve_size) = delta_x_pp;
               //        std::cout << delta_x_pp.transpose() << std::endl;
       
               // TODO:: home work. step3: solve landmark
               VecX delta_x_ll(marg_size);
               // æ³¨æ„: æ­¤å¤„å’Œè¯¾ä»¶çš„å…¬å¼(6)ä¸åŒ, bmmå‰æ²¡æœ‰è´Ÿå·, æ˜¯å› ä¸ºæ„é€ ä¸‰è§’é˜µçš„æ—¶å€™, å·²ç»ç»™bè®¾å®šäº†è´Ÿå·,å¦‚ä¸‹:
               //       b.segment(index_i, dim_i).noalias() -= JtW * edge.second->Residual();
               delta_x_ll = Hmm_inv * ( bmm -  Hmp * delta_x_pp); 
               delta_x_.tail(marg_size) = delta_x_ll;
           }
       }
       ```
  
- 3. ä¿®æ”¹ `problem.cc` ä¸­çš„ `Problem::TestMarginalize()` å‡½æ•°ï¼š
     
     - ä¿®æ”¹çš„åçš„ `TestMarginalize()`ä»£ç å¦‚ä¸‹:
     
       ```C++
       void Problem::TestMarginalize() {
       
           // Add marg test
           int idx = 1;            // marg ä¸­é—´é‚£ä¸ªå˜é‡
           int dim = 1;            // marg å˜é‡çš„ç»´åº¦
           int reserve_size = 3;   // æ€»å…±å˜é‡çš„ç»´åº¦
           double delta1 = 0.1 * 0.1;
           double delta2 = 0.2 * 0.2;
           double delta3 = 0.3 * 0.3;
       
           int cols = 3;
           MatXX H_marg(MatXX::Zero(cols, cols));
           H_marg << 1./delta1, -1./delta1, 0,
                   -1./delta1, 1./delta1 + 1./delta2 + 1./delta3, -1./delta3,
                   0.,  -1./delta3, 1/delta3;
           std::cout << "---------- TEST Marg: before marg------------"<< std::endl;
           std::cout << H_marg << std::endl;
       
           // TODO:: home work. å°†å˜é‡ç§»åŠ¨åˆ°å³ä¸‹è§’
           /// å‡†å¤‡å·¥ä½œï¼š move the marg pose to the Hmm bottown right
           // å°† row i ç§»åŠ¨çŸ©é˜µæœ€ä¸‹é¢
           Eigen::MatrixXd temp_rows = H_marg.block(idx, 0, dim, reserve_size);
           Eigen::MatrixXd temp_botRows = H_marg.block(idx + dim, 0, reserve_size - idx - dim, reserve_size);
           H_marg.block(idx, 0, reserve_size - idx - dim, reserve_size) = temp_botRows;
           H_marg.block(reserve_size - dim, 0, dim, reserve_size) = temp_rows;
       
           // å°† col i ç§»åŠ¨çŸ©é˜µæœ€å³è¾¹
           Eigen::MatrixXd temp_cols = H_marg.block(0, idx, reserve_size, dim);
           Eigen::MatrixXd temp_rightCols = H_marg.block(0, idx + dim, reserve_size, reserve_size - idx - dim);
           H_marg.block(0, idx, reserve_size, reserve_size - idx - dim) = temp_rightCols;
           H_marg.block(0, reserve_size - dim, reserve_size, dim) = temp_cols;
       
           std::cout << "---------- TEST Marg: å°†å˜é‡ç§»åŠ¨åˆ°å³ä¸‹è§’------------"<< std::endl;
           std::cout<< H_marg <<std::endl;
       
           /// å¼€å§‹ marg ï¼š schur
           double eps = 1e-8;
           int m2 = dim;
           int n2 = reserve_size - dim;   // å‰©ä½™å˜é‡çš„ç»´åº¦
           Eigen::MatrixXd Amm = 0.5 * (H_marg.block(n2, n2, m2, m2) + H_marg.block(n2, n2, m2, m2).transpose());
       
           Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> saes(Amm);
           Eigen::MatrixXd Amm_inv = saes.eigenvectors() * Eigen::VectorXd(
                   (saes.eigenvalues().array() > eps).select(saes.eigenvalues().array().inverse(), 0)).asDiagonal() *
                                     saes.eigenvectors().transpose();
       
           // TODO:: home work. å®Œæˆèˆ’å°”è¡¥æ“ä½œ
           Eigen::MatrixXd Arm = H_marg.block(0,n2,n2,m2);
           Eigen::MatrixXd Amr = H_marg.block(n2,0,m2,n2);
           Eigen::MatrixXd Arr = H_marg.block(0,0,n2,n2);
       
           Eigen::MatrixXd tempB = Arm * Amm_inv;
           Eigen::MatrixXd H_prior = Arr - tempB * Amr;
       
           std::cout << "---------- TEST Marg: after marg------------"<< std::endl;
           std::cout << H_prior << std::endl;
       }
       ```
  
- 4.ç¼–è¯‘å¹¶æ‰§è¡Œ ./testMonoBA,  æ‰§è¡Œç»“æœå¦‚ä¸‹: 

  ```PowerShell
  0 order: 0
  1 order: 6
  2 order: 12
  
   ordered_landmark_vertices_ size : 20
  iter: 0 , chi= 5.35099 , Lambda= 0.00597396
  iter: 1 , chi= 0.0289048 , Lambda= 0.00199132
  iter: 2 , chi= 0.000109162 , Lambda= 0.000663774
  problem solve cost: 1.07113 ms
    makeHessian cost: 0.557268 ms
  
  Compare MonoBA results after opt...
  after opt, point 0 : gt 0.220938 ,noise 0.227057 ,opt 0.220992
  after opt, point 1 : gt 0.234336 ,noise 0.314411 ,opt 0.234854
  after opt, point 2 : gt 0.142336 ,noise 0.129703 ,opt 0.142666
  after opt, point 3 : gt 0.214315 ,noise 0.278486 ,opt 0.214502
  after opt, point 4 : gt 0.130629 ,noise 0.130064 ,opt 0.130562
  after opt, point 5 : gt 0.191377 ,noise 0.167501 ,opt 0.191892
  after opt, point 6 : gt 0.166836 ,noise 0.165906 ,opt 0.167247
  after opt, point 7 : gt 0.201627 ,noise 0.225581 ,opt 0.202172
  after opt, point 8 : gt 0.167953 ,noise 0.155846 ,opt 0.168029
  after opt, point 9 : gt 0.21891 ,noise 0.209697 ,opt 0.219314
  after opt, point 10 : gt 0.205719 ,noise 0.14315 ,opt 0.205995
  after opt, point 11 : gt 0.127916 ,noise 0.122109 ,opt 0.127908
  after opt, point 12 : gt 0.167904 ,noise 0.143334 ,opt 0.168228
  after opt, point 13 : gt 0.216712 ,noise 0.18526 ,opt 0.216866
  after opt, point 14 : gt 0.180009 ,noise 0.184249 ,opt 0.180036
  after opt, point 15 : gt 0.226935 ,noise 0.245716 ,opt 0.227491
  after opt, point 16 : gt 0.157432 ,noise 0.176529 ,opt 0.157589
  after opt, point 17 : gt 0.182452 ,noise 0.14729 ,opt 0.182444
  after opt, point 18 : gt 0.155701 ,noise 0.182258 ,opt 0.155769
  after opt, point 19 : gt 0.14646 ,noise 0.240649 ,opt 0.14677
  ------------ pose translation ----------------
  translation after opt: 0 :-0.000477994   0.00115908  0.000366504 || gt: 0 0 0
  translation after opt: 1 :-1.06959  4.00018 0.863877 || gt:  -1.0718        4 0.866025
  translation after opt: 2 :-4.00232  6.92678 0.867244 || gt:       -4   6.9282 0.866025
  ---------- TEST Marg: before marg------------
       100     -100        0
      -100  136.111 -11.1111
         0 -11.1111  11.1111
  ---------- TEST Marg: å°†å˜é‡ç§»åŠ¨åˆ°å³ä¸‹è§’------------
       100        0     -100
         0  11.1111 -11.1111
      -100 -11.1111  136.111
  ---------- TEST Marg: after marg------------
   26.5306 -8.16327
  -8.16327  10.2041
  
  ```

## æå‡é¢˜
#### paper reading, è¯·æ€»ç»“è®ºæ–‡: ä¼˜åŒ–è¿‡ç¨‹ä¸­å¤„ç† $\mathbf{H}$ è‡ªç”±åº¦çš„ä¸åŒæ“ä½œæ–¹å¼. æ€»ç»“å†…å®¹åŒ…æ‹¬: å…·ä½“å¤„ç†æ–¹å¼, å®ç°æ•ˆæœ, ç»“è®º.

```
Zichao Zhang, Guillermo Gallego, and Davide Scaramuzza. "On the comparison of gauge freedom handling in optimization-based visual-inertial state estimation".  In: IEEE Rototics and Automation Letters 3.3 (2018)
```
#### å›ç­”

 #####  ä¸‰ç§æ“ä½œæ–¹å¼ä»‹ç»:

- Gauge fixation:
  - æ•´ä¸ªä¼˜åŒ–è¿‡ç¨‹ä¸­, ç¬¬ä¸€ä¸ªç›¸æœºpositionå’Œyawè§’éƒ½ä¿æŒå›ºå®š ( é€šè¿‡è®¾å®šæ®‹å·®å‘é‡çš„JacobiançŸ©é˜µä¸­å¯¹åº”åˆ—ä¸º0, $ \mathbf{J}_{p0} = 0, \mathbf{J}_{\Delta\phi_{0z}} = 0$ )

- Gauge prior:
  - åœ¨gauge fixationçš„åŸºç¡€ä¸Šå¢åŠ æƒ©ç½šé¡¹: $\left\|\mathbf{r}_{0}^{P}\right\|_{\Sigma_{0}^P}^{2}, \quad$ where $\quad \mathbf{r}_{0}^{P}(\boldsymbol{\theta}) \doteq\left(\mathbf{p}_{0}-\mathbf{p}_{0}^{0}, \Delta \phi_{0 z}\right)$, å…ˆéªŒåæ–¹å·® $\Sigma_0^P$ å¯ä»¥é€‰ $\sigma_0^2 I$ , åˆ™$\left\|\mathbf{r}_{0}^{P}\right\|_{\Sigma_{0}^{P}}^{2}=w^{P}\left\|\mathbf{r}_{0}^{P}\right\|^{2},$ with $w^{P}=1 / \sigma_{0}^{2}$ 

- Free Gauge:
  - æ•´ä¸ªä¼˜åŒ–è¿‡ç¨‹ä¸­,æ‰€æœ‰å‚æ•°å‘é‡éƒ½å¯ä»¥è¢«æ¶‰åŠ. ä½¿ç”¨ä¼ªé€†çš„LMæ–¹æ³•æ¥æœ€å°åŒ–æ®‹å·®( æ€»æ˜¯å‚ç›´äºç­‰å€¼çº¿)

##### æ•ˆæœæ¯”è¾ƒä¸ç»“è®º:

- ä¸‰ç§å¤„ç†åŸºæœ¬ä¸Šæœ‰ç›¸åŒçš„ç²¾åº¦;
- Gauge priorå¤„ç†éœ€è¦é€‰æ‹©ä¸€ä¸ªæ­£ç¡®çš„å…ˆéªŒæƒé‡, åœ¨æ­¤å‰æä¸‹, å®ƒå…·æœ‰å’ŒGauge fixationç›¸åŒçš„ç²¾åº¦å’Œè®¡ç®—æ•ˆç‡;
-  free gaugeä¸‰è€…ä¸­æœ€è½»é‡å’Œå¿«é€Ÿçš„, å®ƒä½¿ç”¨æœ€å°‘çš„è¿­ä»£æ¬¡æ•°;
- é€šè¿‡åæ–¹å·®çŸ©é˜µçš„æ¯”è¾ƒ(Fig. 9 ):
  -  åœ¨Gauge fixationä¸­, é¦–ä½ç½®çš„ä¸ç¡®å®šåº¦ä¸º0,  ç„¶åé€æ­¥å‘å³ä¸‹è§’å¢é•¿;  
  - è€ŒFree gaugeä¸­, ä¸ç¡®å®šåº¦æ˜¯"åˆ†å¸ƒ"åœ¨å„ä¸ªä½ç½®ä¸Šçš„( ä¸å›ºå®šåˆ°ä»»ä½•ä¸€å¸§ );
  - Free gaugeçš„åæ–¹å·®çŸ©é˜µä¹Ÿä¸å…·å¤‡ä»»ä½•å‡ ä½•æ„ä¹‰ä¸Šçš„è§£é‡Š,  ä½†å¯ä»¥é€šè¿‡ä¸€ä¸ªçº¿æ€§å˜æ¢æŠŠfree gaugeåæ–¹å·®è½¬ä¸ºgauge fixationåæ–¹å·®,  ä¸”ä»Fig.9 bå¯ä»¥çœ‹å‡ºå®ƒä»¬é«˜åº¦å»åˆ(å…·ä½“æ–¹æ³•è§ Section VI-B); 

![](D:\Study\vio\5\images\cov_matrix.PNG)

